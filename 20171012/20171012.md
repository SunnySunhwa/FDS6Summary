# 실행 컨텍스트와 자바스크립트의 동작 원리
  * 잘 알면 디버깅을 잘 할 수 있다.
## 실행 컨텍스트
  * 실행 가능한 코드를 형상화하고 구분하는 추상적 개념(ECMAScript)
    * 실행 가능한 코드: 전역코드와 함수코드(Eval함수 코드는 사용 금지)
  * 코드 실행을 위한 정보
    * 변수: 전역변수, 지역변수, 매개변수, 객체의 프로퍼티.
    * 함수 선언: 함수명(무명함수 제외)과 함수 자체  
    * 변수의 유효범위(Scope)
    * this: 이 this가 가리키는 것이 무엇인가?
 * 실행 컨텍스트 스택(콜 스택)과 코드 실행 순서
   * 실행 컨텍스트(EC)가 쌓이는 메모리상의 공간
   * 전전 실행 컨텍스트는 브라우저를 종료할 때까지 계속 메모리 공간 점유

## 실행 컨텍스트의 3가지 객체
  1. Variable Object(변수객체)
  * 변수, 매개변수(parameter), 인수정보(arguments), 함수선언(변수로 취급되는 함수표현식은 제외)을 담고 있음.
  * 전역 컨텍스트에서 VO는 전역객체(GO/ window, global)를 가르키며 그 안에 세팅해 놓는다. (전역 객체는 전역 컨텍스트 이전인, 브라우저를 켜는 순간 태초부터 존재했다.)
    * 전역 변수는 왜 전역 객체의 프로퍼티인가에 대한 이야기
    * 함수 컨텍스트에서 VO는 활성객체(AO, Activation Object)를 가리킨다.

  2. Scope Chain
  * 다이렉트로 가리키는게 아니다. 스코프가 여러 개가 있을 수 있기 때문에 배열처럼 리스트화된 단계를 거친다. 순서가 있어서 0인 자신의 AO를 보고 그래도 없으면 두번째인 1, 상위(본 예제에서는 전역)인 GO를 본다.
   * 즉, 그 중간 단계는 스코프 판단을 위한 단계

  3. this value
  * this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

## 실행 컨텍스트의 생성 과정
  ```javascript
  // 판단 예제

  var x = 'xxx';

  function foo () {
    var y = 'yyy';

    function bar () {
      var z = 'zzz';
      console.log(x + y + z);
    }
    bar();
  }
  foo();
  ```
  
  * 전역 코드에의 진입
    * 이 상태는 전역 코드 실행 전 단계
    * 초기 상태의 전역객체는 빌트인 객체와 BOM, DOM 등이 있다.
    1. 스코프 체인의 생성과 초기화
    2. Variable Instantiation(변수 객체화) 실행
        1. 함수 foo의 선언 처리 : 함수 호이스팅의 원리(scope판단을 위해 이미 함수의 내용을 다 갖고 있음)
        2.  변수 x의 선언 처리 : 변수 호이스팅의 원리(선언, 초기화만 수행)
    3. this value 결정

  * 전역 코드의 실행
    1. 변수 값의 할당 : 전역변수 x에 문자열 ‘xxx’를 할당
    2. 함수 foo의 실행 : `전역 코드에의 진입`의 경우와 마찬가지로 다음 3단계 거침
        1. 스코프 체인의 생성과 초기화
        2. Variable Instantiation 실행
        3.  this value 결정

  * foo 함수 코드의 실행
    * `전역 코드의 실행`과 마찬가지 과정을 반복한다.
    1. 변수 값의 할당: 지역변수 y에 문자열 'yyy'를 할당
    2. 함수 bar의 실행: 이 단계에서 `console.log(x + y + z);`의 실행 결과는 xxxyyyzzz가 된다.


# 클로저 - Closure

##클로저의 개념
자바스크립트에서 중요한 개념. 
*일급객체 : 객체를 값 처럼 사용 가능
일급 객체를 취급하는 함수형 언어에서 사용 된다.
내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미. 이때의 변수는 자유변수이다.
 - 즉 내부함수는 외부함수를 참조 할 수 있다.
 - 내부함수의 스코프는 외부함수의 스코프를 참조할수 있다.


##클로저 전제 조건
 외부함수 와 내부함수로 이뤄져 있고 내부함수는 외부함수를 참조한다

## 클로저 단점
무분별한 클로저의 사용은 득보다는 실이 많다. 클로저 작동이 종료가 되어도 외부함수 의 VO가 메모리에 남아있게 되어 많이 사용하면 해당 건이 누적되어 성능이 떨어지게 된다. 

## 예제
아래의 링크를 통해 클로저 예제를 공부해보자
[예제 링크](http://poiemaweb.com/js-closure#2-클로저의-활용)

# 자바스크립트 객체 지향 프로그래밍
객체지향 프로그래밍은 실세계에 존재하고 인지하고 있는 객체(Object)를 소프트웨어의 세계에서 표현하기 위해 객체의 핵심적인 개념 또는 기능만을 추출하는 추상화(abstraction)를 통해 모델링하려는 프로그래밍 패러다임을 말한다

객체지향 프로그래밍은 함수들의 집합 혹은 단순한 컴퓨터의 명령어들의 목록이라는 전통적인 절차지향 프로그래밍과는 다른, 관계성있는 객체들의 집합이라는 관점으로 접근하는 소프트웨어 디자인으로 볼 수 있다.

## 클래스 기반 언어
1.클래스란 같은 종류의 집단에 속하는 속성과 행위를 정의한것이다.
2.객체 생성에 사용되는 패턴이기에 반드시 new연산자를 통한 인스턴스화 과정필요.
3.모든 인스턴스는 클래스에서 정의된 범위 내에서만 작동 가능, 런타임에 그 구조 변경 불가
 - 이는 프로토타입기반 언어보다 좀 더 나은 결과를 보장함

## 프로토타입 기반 언어
1. 자바스크립트는 별도의 객체 생성 방법이 존재함
2. 생성된 인스턴스의 자료구조와 기능을 동적 변경 가능.
3. 상속, 캡슐화등은 프로토타입 체인과 클로저 등으로 구현 가능.

## 상속
- 자바스크립트는 프로토타입을 통해 객체가 다른 객체로 직접 상속 구현.
### 의사 클래스 패턴 상속
- 자식 생성자 함수의 prototype 프로퍼티를 부모 생성자 함수의 인스턴스로 교체하여 구현하는 방법
- 문제점
 1) new연산자를 통해 인스턴스를 생성하는 불필요한 단계 존재
 2) 생성자 링크의 파괴 상속 받은 인스턴스는 constructor와의 연결이 꺠지게 된다
 3) 객체 리터럴 패턴에 의한 객체에는 부적합

### 프로토타입 패턴 상속
-  Object.create 함수를 사용하여 객체에서 다른 객체로 직접 상속을 구현하는 방식이다. 의사 클래스 패턴 상속의 문제점을 보완함.


* 자바스크립트는 클래스 기반 언어가 아니므로 기존의 전통적 방식으로 구현하려는 시도는 당시 상황에 최선의 노력이었다. 하지만 현재는 자바스크립트 언어에 매우 효과적인 프레임 워크가 있으니 이를 충분히 활용하고, 자바스크립트만의 방식을 잘 활용하여 보다 효율적인 프로그래밍을 추구해야한다. 



