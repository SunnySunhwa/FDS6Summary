# Number

# Math

# RegExp;정규표현식
정규표현식을 사용하면 복잡한 기호를 간단하게(?) 사용해서 문자열을 손쉽게(?) 처리할 수 있다. 프로그래밍 언어를 구분하지 않고 공통된 문법을 따르며, 자바스크립트 내장 메소드와 함께 사용하여 참 거짓, 원하는 문자열이나 배열, 인덱스 등을 구할 수 있다.

## 표현 방법
/expression/[,i, g, m...]

* 슬래시는 시작과 끝을 나타낸다.
* 슬래시 내부에 표현식을 작성한다.
* (선택)슬래시 외부에 플래그를 붙일 수 있다.

## 표현식 패턴
패턴을 표현하기 위해 약속된 기호들이 있다.

* . 임의의 문자 '한개'를 찾는다(n개 찍으면 n개)
* ^ 뒤에 이어지는 패턴을 맨 앞에서 찾는다
* $ 앞에 붙는 패턴을 맨 뒤에서 찾는다
* {} 내부에는 찾고자 하는 문자열의 개수를 입력한다. 두 수를 쉼표로 구분 시 범위를 의미한다.
* \+ 를 패턴 뒤에 붙이면 반복을 허용한다는 뜻이다
* | 는 or의 의미를 가지며, 좌우 패턴을 모두 찾는다
* [] 내부의 문자는 모두 'or' 패턴이다
* \- 를 사용해 범위를 지정한다. 단 [] 내부에서 사용한다. (e.g. [0-9A-Z])
* 숫자, 문자열 대체기호
  * \d : 숫자
  * \D : !숫자
  * \w : 알파벳이랑 숫자
  * \W : !알파벳 && !숫자
* 공백/줄바꿈 기호 표시법
  * /n : 개행문자
  * /s : 공백문자(스페이스)
  * /t : 공백문자(탭)

## 플래그의 종류
플래그는 문자열 검색 옵션을 지정한다.
* i(ignore) : 대소문자 구분없이 검색
* g(global) : 문자열 전체 검색
* m(multi line) : 줄바꿈 무시

## 자주쓰는 패턴
* `/^abc/` : abc로 시작하는지 검사
* `/ef$/` : ef로 끝나는지 검사
* `/^\s+/` : 공백(\s)으로 시작하는지 검사

## 자바스크립트에서 사용하기
`RegExp` 생성자 함수가 존재하여 정규표현식 '객체'를 생성할 수 있다. 즉 정규표현식 객체는 프로토타입의 메소드와 함께 사용할 수 있다. 그 외에 `String` 프로토타입의 메소드도 정규표현식 객체를 사용한다.  
보통은 생성 시 리터럴을 사용한다.

* RegExp.prototype 메소드
  * exec()
    * 첫번째 매칭만 반환. g 플래그 무시
    * 매칭문자열, 첫문자의 인덱스, 타겟문자열로 구성된 배열 또는 null(못찾을 경우) 반환
  * test()
    * 매칭 시 true, 아닐 시 false 반환
  * ...

* String.prototype 메소드
  * match()
    * 매칭된 문자열을 가진 배열 반환
  * replace()
    * 매칭된 문자열을 교체한다
  * ...

# Array;배열

* 프로퍼티명이 없는(대신 인덱스 넘버가 있는) *객체*
* 어떤 자료형도 배열 요소가 될 수 있다
* `for in` or `for`?  
  배열 요소를 열거 또는 순회하기 위해서 반복문을 자주 사용한다. `for in`문은 다음과 같은 이유로 자주 쓰지는 않는다.
  1. 성능 저하
  1. 불필요한 프로퍼티(index) 출력
* `length` property  
*유사 배열 객체*인 string, arguments 역시 가지고 있는 length 프로퍼티는 요소의 갯수를 값으로 가지고 있다.

## 생성하기

* 생성자 함수 Array 사용
  * 인자로 한개의 숫자를 전달하면 해당 길이의 배열을 반환하며, 각 요소의 값은 `undefined`
  * 인자로 숫자가 아닌 것 또는 2개 이상의 숫자를 전달하면 전달된 인자(들)를 요소로 가진 배열을 반환한다.
  * 하지만 거의 리터럴 방식을 사용한다.
* 리터럴 방식

## Array.prototype methods
**각 메소드가 원본 배열을 변경하는지 안하는지 아는 것이 중요하다.**

* `.indexOf()`
  * 인덱스 넘버 반환(0 <= i < length)
  * 한개만 찾는다
  * 못찾으면 -1 반환

* `.concat()`
  * 원본 변경 X
  * 인자로 전달받은 배열 또는 값을 자신을 호출한 배열객체에 추가한다. 배열을 전달할 경우 요소로 풀어서 추가한다.

* `.join()`
  * 원본 변경 X
  * 배열의 모든 요소를 구분자를 사용해 이어붙인 문자열로 반환.
  * 구분자는 인자로 전달하며, 기본값은 콤마
  * 빠르다(각 요소 더하기보다)

* `.pop()`
  * 원본 변경 O
  * LIFO(as stack)
  > FIFO(as queue)
  * 마지막 요소를 배열에서 빼고, 해당 요소를 반환한다

* `.shift()`
  * pop과 비슷한데 맨 앞의 요소를 대상으로 한다.

* `.push()`
  * 인자를 배열의 *끝에* 추가한다
  * 인자로 전달받은 배열을 *풀지않고* 그대로 추가한다.(물론 인자로 배열 외 다른 타입을 전달할 수도 있다)
  * 변경된 배열의 length를 반환한다

* `.unshift()
  * push와 비슷한데 맨 앞의 요소를 대상으로 한다.

* `.slice()`
  * 배열의 일부분을 *복사한다*
  * **!!인자가 없으면 배열 전체를 대상으로 한다!!**
  > 원본 배열을 변경하지 않고 사용하고 싶을 때 매우 자주 사용한다.

* `.splice()`
  * (start, deleteCount [, items...])
  * 배열의 중간에 아이템을 추가
  * **!!중간 삽입 시 두번째 인자로 0을 전달!!**
  > 위 방식은 매우 자주 쓴다
  * 아이템이 배열일 경우, 배열 자체가 통째로 삽입된다. 이때 apply를 사용한다.
  > apply는 인자로 전달된 배열을 풀어버리는 점을 활용한다

* `.sort()`
  * 원본 배열 수정 O
  * 순서가 변경된 배열을 반환한다.
  * 문자열 기준으로 정렬한다.
  > 숫자 크기를 기준으로 정렬할 땐 콜백함수를 사용한다.

### !!!!중요한 메소드!!!!

* `.forEach()`
  * (callback [, `this`])
  * 인자로 전달받은 콜백함수를, 배열의 모든 요소에 대하여 반복실행한다.
  * 이때 함수 내부에서 배열의 요소, 인덱스, 배열자신을 매개변수로 사용할 수 있다.

> application 내부의 함수를 돌다보면 this가 "깨지기" 일쑤이므로 , 콜백 함수에서 this 키워드의 초점을 유지하는 것은 매우 중요하다.

```javascript
function Counter() {
  this.sum = 0;
  this.count = 0;
}
Counter.prototype.add = function (array) {
  /* this === instance or prototype BUT,
  forEach의 인자인 콜백함수 내부에서 this === window */
  array.forEach(function (entry) {
    this.sum += entry; // 2번째 인자 this를 전달하지 않으면 this === window
    this.count++;
  }, this); // 2번째 인자에 this 를 전달하였다.
};

var obj = new Counter();
obj.add([2, 5, 9]);
console.log(obj.count); // 3
console.log(obj.sum);   // 16
```

* `.map()`
  * 원본 배열 변경 X
  * 새로운 배열 반환
  * 각 요소 >> 콜백 함수 >> 리턴 >> 새로운 배열의 요소로 추가 >> 반복
  * `forEach()`와 마찬가지로, 콜백함수는 요소, 인덱스, 배열의 순서로 인자를 전달받는다
  * 콜백함수에서 `return` 구문을 빼먹으면 변경이 안된다